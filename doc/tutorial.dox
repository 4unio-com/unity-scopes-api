/*!

\page tutorial Tutorial

This short tutorial covers the basic steps and building blocks needed for implementing your own scope with unity-scopes-api, using C++. For complete examples
of various scopes see demo/scopes subdirectory.

\section simplescope A simple scope which doesn't query other scopes.

This is the typical case: a scope that connects to a remote or local backend, database etc. and provides results in response to search queries coming from a
client (i.e. Unity Dash or another scope).

\subsection scopebase Create a scope class that implements ScopeBase inteface.

There are a few pure virtual methods that need to be implemented; at the very minimum you need to provide a non-empty implementation of
\link unity::scopes::ScopeBase::start() start\endlink and \link unity::scopes::ScopeBase::create_query() create_query\endlink  and
unity::scopes::ScopeBase::preview() methods. 

\code{.cpp}
class MyScope: public unity::scopes::ScopeBase
{
public:
    virtual int start(std::string const&, unity::scopes::RegistryProxy const&) override;
    virtual void stop() override;
    virtual void run() override;
    virtual unity::scopes::SearchQuery::UPtr create_query(Query const& query, SearchMetadata const& metadata) override;
    virtual unity::scopes::PreviewQuery::UPtr preview(unity::scopes::Result const& result, unity::scopes::ActionMetadata const& metadata) override;
}
\endcode

The \link unity::scopes::ScopeBase::start() start\endlink method must, at the very least return ScopeBase::VERSION, e.g.

\code{.cpp}
int MyScope::start(string const&, unity::scopes::RegistryProxy const&)
{
    return ScopeBase::VERSION;
}
\endcode

The \link unity::scopes::ScopeBase::stop() stop\endlink method should release any resources, such as network connections where applicable. See the
documentation of \link unity::scopes::ScopeBase ScopeBase\endlink for an explanation of when \link unity::scopes::ScopeBase::run() ScopeBase::run\endlink;
is useful; for typical and simple cases the implementation of run can be an empty function.

\subsection handlingsearch Handling search

The \link unity::scopes::ScopeBase::create_query() create_query\endlink method of scope implementation is the entry point of every search - it receives
search queries from the Dash or other scopes. This method must return an instance of an object that implements
\link unity::scopes::SearchQuery SearchQuery\endlink interface, e.g:

\code{.cpp}
SearchQuery::UPtr MyScope::create_query(Query const& query, SearchMetadata const& metadata)
{
    SearchQuery::UPtr q(new MyQuery(query));
    return q;
}
\endcode

\subsubsection querybase Create a query class that implements SearchQuery interface.

The central and most important method that needs to be implemented in this interface is \link unity::scopes::SearchQuery run\endlink.
This is where actual processing of current search query takes place, and this is the spot where you may want to query local or remote data source for results
matching the query.

The \link unity::scopes::SearchQuery run\endlink method gets passed an instance of SearchReplyProxy, which represents a receiver of query results. Please note
that SearchReplyProxy is just a shared pointer for \link unity::scopes::SearchReply SearchReply\endlink object. The two most important
methods of SearchReply object that every scope have to use are \link unity::scopes::SearchReply::register_category register_category\endlink
and \link unity::scopes::SearchReply::push push\endlink.

The \link unity::scopes::SearchReply::register_category register_category\endlink method is a factory method for creating new categories (see
\link unity::scopes::Category\endlink). Categories can be created at any point during query processing inside run method, but it's recommended to create
them as soon as possible (ideally as soon as they are known to the scope).

When creating a category, one of its parameters is a \link unity::scopes::CategoryRenderer \endlink instance,
which specifies how will a particular category be rendered. See the unity::scopes::CategoryRenderer documentation for more on that subject.

The actual search results have to be wrapped inside \link unity::scopes::CategorisedResult CategorisedResult\endlink objects and
passed to \link unity::scopes::SearchReply::push push\endlink.

A typical implementation of run may look like this:

\code{.cpp}
void MyQuery::run(SearchReplyProxy const& reply)
{
    auto category = reply->register_category("recommended", "Recommended", icon);
    //... query a local or remote backend

    for (auto res: backend.get_results(search_query)) // for every result returned by a backend
    {
        ...
        CategorisedResult result(category); // create a result item in "recommended" category
        result.set_uri(...);
        result.set_title(...);
        result.set_art(...);
        result.set_dnd_uri(...);
        result["my-custom-attribute"] = Variant(...); // add arbitrary data as needed

        if (!reply->push(result)) // send result to the client
        {
            break; // false from push() means search was cancelled
        }
    }
}
\endcode

\subsection handlingpreview Handling previews

Scopes are responsible for handling preview requests for results they created; this needs to be implemented by overriding unity::scopes::ScopeBase::preview()
method:

\code{.cpp}
class MyScope: public unity::scopes::ScopeBase
{
public:
    ...
    virtual unity::scopes::PreviewQuery::UPtr preview(unitu::scopes::Result const& result, unity::scopes::ActionMetadata const& metadata) override;
    ...
}
\endcode

This method must return an instance derived from unity::scopes::PreviewQuery. The implementation of unity::scopes::PreviewQuery interface is similar to
unity::scopes::SearchQuery in that its central method is unity::scopes::PreviewQuery::run(). This method is responsible for gathering preview data (from
local or remote sources) and passing it along with the definition of preview look to unity::scopes::PreviewReplyProxy (this is a pointer to
unity::scopes::PreviewReplyBasel; the run() method receives a pointer to an instance of unity::scopes::PreviewReply).

A preview consists of one or more preview widgets - these are the basic building blocks for previews, such as a header with a title and subtitle, an image, a
gallery with multiple images, a list of audio tracks etc.; see unity::scopes::PreviewWidget for a detailed documentation and a list of supported widget types.
So, the implementation of unity::scopes::PreviewQuery::run() needs to create and populate one or more instances of unity::scopes::PreviewWidget and push them to the
client with unity::scopes::PreviewReply::push().

Every unity::scopes::PreviewWidget has a unique identifier, a type name and a set of attributes determined by its type. For example, a widget of "image" type expects
two attributes: "source", which should point to an image (an uri) and "zoomable" boolean flag, which determines if the image should be zoomable. Values of such
attributes can either be specified directly, or they can reference values present already in the unity::scopes::Result instance, or pushed spearately during the
execution of unity::scopes::PreviewQuery::run().

Attributes can be specified directly with unity::scopes::PreviewWidget::add_attribute() method, e.g:

\code{.cpp}
    PreviewWidget image_widget("myimage", "image");

    image_widget.add_attribute("source", Variant("file:///tmp/image.jpg"));
    image_widget.add_attribute("zoomable", Variant(false));
\endcode

To reference values from results or arbitrary values pushed separately, use unity::scopes::PreviewWidget::add_component() method:

\code{.cpp}
    PreviewWidget image_widget("myimage", "image");
    image_widget.add_component("source", "art"); // use 'art' attribute from the result
    image_widget.add_component("zoomable", "myzoomable"); // 'myzoomable' not specified, but pushed below
    reply->push("myzoomable", Variant(true));
\endcode

To push preview widgets to the client, use unity::scopes::PreviewReply::push():

\code{.cpp}
    PreviewWidget image_widget("myimage", "image");
    PreviewWidget header_widget("myheader", "header");
    // fill in widget attributes
    ...
    PreviewWidgetList widgets { image_widget, header_widget };
    reply->push(widgets);
\endcode

\subsubsection previewactions Preview actions

Previews can have actions (i.e. buttons) that user can activate - they are supported by unity::scopes::PreviewWidget of "actions" type. This type of widget
takes one or more action button definitions, where every button is constituted by an unique identifier, a label and an optional icon. For example, a widget with
two buttons: "Open" and "Download" can be defined as follows (using unity::scopes::VariantBuilder helper class):

\code{.cpp}
    PreviewWidget buttons("mybuttons", "actions");

    VariantBuilder builder;
    builder.add_tuple({
        {"id", Variant("open")},
        {"label", Variant("Open")}
    });
    builder.add_tuple({
        {"id", Variant("download")},
        {"label", Variant("Download")}
    });

    buttons.add_attribute("actions", builder.end());
\endcode

To handle activation of preview actions, scope needs to implement the following method of unity::scopes::ScopeBase:

\code{.cpp}
class MyScope: public unity::scopes::ScopeBase
{
    virtual ActivationBase::UPtr perform_action(Result const& result, ActionMetadata const& metadata, std::string const& widget_id, std::string const& action_id) override
    ...
}
\endcode

This method receives a widget identifier and action identifier that was activated. 
This method needs to return an instance derived from unity::scopes::ActivationBase. The derived class needs to reimplement
unity::scopes::ActivationBase::activate() method and put any activation logic in there. This method needs to respond with an instance of
unity::scopes::ActivationResponse, which informs the shell about status of activation and the expected behaviour of the UI. For example, activate() may request
a new search query to be executed as follows:

\code{.cpp}
class MyActivation : public unity::scopes::ActivationBase
{
    virtual unity::scopes::ActivationResponse activate() override
    {
        ...
        if (action_id == "search-grooveshark")
        {
            Query query("com.canonical.scopes.grooveshark");
            query.set_query_string("metal");
            return unity::scopes::ActivationResponse(query);
        }
        ...
    }
}
\endcode

\subsection handlingactivation Handling result activation

In most cases search results can be activated (i.e. when user taps or clicks them) directly by the shell - as long as a desktop schema used by that result's uri is
known to the shell. In some cases however scope may want to intercept and handle activation request. To do that, it has to reimplement
unity::scopes::ScopeBase::activate() method:

\code{.cpp}
class MyScope : public ScopeBase
{
    virtual ActivationBase::UPtr activate(Result const& result, ActionMetadata const& metadata) override;
    ...
}
\endcode

and also call Result::set_intercept_activation() for all results that should trigger unity::scopes::ScopeBase::activate() on activation. The implementation of
unity::scopes::ScopeBase::activate() should follow the same guidelines as unity::scopes::ScopeBase::perform_action(), the only difference with result activation
being the lack of widget or action identifiers, as those are specific to preview widgets.

\subsection export Export the scope.

The scope needs to be compiled into a .so shared library and to be succesfully
loaded at runtime it must provide two C functions to create and destroy it - a
typical code snippet to do this looks as follows:

\code{.cpp}
extern "C" {
    EXPORT unity::scopes::ScopeBase* UNITY_SCOPE_CREATE_FUNCTION()
    {
        return new MyScope();
    }

    EXPORT void UNITY_SCOPE_DESTROY_FUNCTION(unity::scopes::ScopeBase* scope_base)
    {
        delete scope_base;
    }
}
\endcode

\section aggscope A simple aggregator scope which combines results from other scopes.

Aggregator scope is not much different from regular scopes, except for its data sources can include any other scope(s). The main difference is in the
implementation of run method of \link unity::scopes::SearchQuery SearchQuery\endlink and in the new class that has to implement
\link unity::scopes::SearchListener SearchListener\endlink interface, which receives result from other scope(s).

\subsection subquery Query another scopes via SearchQuery::create_subquery()

To send search query to another scope, use one of the `create_subquery()` overloads of \link unity::scopes::SearchQuery SearchQuery\endlink inside your implementation of SearchQuery.
This method requires - among search query string - an instance of \link unity::scopes::ScopeProxy ScopeProxy\endlink that points to the target scope and an instance of class that implements
\link unity::scopes::SearchListener SearchListener\endlink interface. ScopeProxy can be obtained from unity::scopes::RegistryProxy and the right place to
do this is in the implementation of \link unity::scopes::ScopeBase::start() start()\endlink method of \link unity::scopes::ScopeBase ScopeBase\endlink interface.

\code{.cpp}

int MyScope::start(std::string const&, unity::scopes::RegistryProxy const& registry)
{
    try
    {
        scope_to_query_ = registry->find("scope-A"); // store the proxy for passing it further in create_query
    }
    catch (NotFoundException const& e)
    {
        ...
    }
    return VERSION;
}

unity::scopes::QueryBase::UPtr MyScope::create_query(std::string const& query, unity::scopes::VariantMap const&)
{
    QueryBase::UPtr q(new MyQuery(query, scope_to_query_));
    return q;
}

...

void MyQuery::run(unity::scopes::SearchReplyProxy const& upstream_reply) 
{
    auto category = reply->register_category("recommended", "Recommended", icon, "");
    SearchListener::SPtr reply(new MyReceiver(upstream_reply, category));
    create_subquery(scope_to_query_, query_, VariantMap(), reply);
    ...
}
\endcode

\subsubsection receiver Create a class that implements SearchListener interface

The \link unity::scopes::SearchListener SearchListener\endlink is an abstract class to receive the results of a query sent to a scope. Its virtual push methods let the
implementation receive \link unity::scopes::SearchListener::push result items and categories\endlink returned by that query. A simple implementation of
an aggregator scope may just register all categories it receives and push all received results upstream to the query originator, e.g.

\code{.cpp}

virtual void push(Category::SCPtr category) override
{
    upstream_->register_category(category);
}

void MyReceiver::push(ResultItem result)
{
    upstream_->push(std::move(result));
}
\endcode

A more sophisticated aggregator scope can rearrange results it receives into a different set of categories, alter or enrich the results before pushing them
upstream etc.

\subsection aggactiv Activation and previews of results processed by aggregator scopes

If an aggregator scope just forwards results it receives from other scopes, possibly only changing their category assignment, then there is nothing
to do in terms of handling previews, preview actions and result activation: preview and perform_action requests will trigger respective methods of
unity::scopes::ScopeBase for the scope that created results. Result activation will trigger unity::scopes::ScopeBase::activate() method for the scope that
produced the result as long as it set interception flag for it. In other words, when aggreagor scope just forwards results (and makes only minor
adjustements to them, such as category assignment), it is not involved in preview or activation handling at all.

If, however, aggregator scope 

*/

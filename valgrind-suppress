# Leak suppressions for Ice below are all for bogus "possibly lost" reports.
# In all cases, we ultimately end up in the std::string library, which does
# weird things with pointers that point somewhere into the middle of an allocated
# block to avoid copies. In turn, that causes bogus reports from valgrind.

# Bogus "possibly leaked" reports for pthreads

{
    Thread create leak
    Memcheck:Leak
    fun:calloc
    ...
    fun:pthread_create@@GLIBC_2.2.5
}

# Bogus "possibly leaked" reports for glib .ini file parser

{
    g_keyfile_new_leak
    Memcheck:Leak
    ...
    fun:g_key_file_new
}

{
    g_keyfile_load_leak
    Memcheck:Leak
    ...
    fun:g_key_file_load_from_file
}

# Bogus "possibly lost" report for
#
#   string s("hello");
#   foo(s + " world");

{
    StringCatenation
    Memcheck:Leak
    fun:_Znwm
    fun:_ZNSs4_Rep9_S_createEmmRKSaIcE
    fun:_ZNSs4_Rep8_M_cloneERKSaIcEm
    fun:_ZNSs7reserveEm
    fun:_ZNSs6appendEPKcm
}

# Leak in dynamic linker

{
    DynLinker
    Memcheck:Leak
    fun:calloc
    obj:*
    fun:_Z24__tracepoints__ptrs_initv
    fun:call_init.part.0
    fun:_dl_init
    obj:/lib/x86_64-linux-gnu/ld-2.18.so
}

{
    DynLinker2
    Memcheck:Leak
    fun:calloc
    obj:*
    fun:__tracepoints__ptrs_init
    fun:call_init.part.0
    fun:_dl_init
    obj:/lib/x86_64-linux-gnu/ld-2.18.so
}

# False positives for memory leaks in Qt

{
   QNetworkConfigurationManager
   Memcheck:Leak
   fun:*alloc
   ...
   fun:_ZN35QNetworkConfigurationManagerPrivate20updateConfigurationsEv
   fun:_ZN35QNetworkConfigurationManagerPrivate10initializeEv
}

{
   QCoreApplication
   Memcheck:Leak
   fun:realloc
   ...
   fun:_ZN7QObject5eventEP6QEvent
   fun:_ZN16QCoreApplication6notifyEP7QObjectP6QEvent
}

{
   QNetworkAccessManager
   Memcheck:Leak
   ...
   fun:_ZN21QNetworkAccessManager13createRequestENS_9OperationERK15QNetworkRequestP9QIODevice
   fun:_ZN21QNetworkAccessManager3getERK15QNetworkRequest
}

{
   QFactoryLoader
   Memcheck:Leak
   fun:*alloc
   ...
   fun:_ZNK14QFactoryLoader8instanceEi
}

# Bogus "invalid read" reports for ::putenv and ::genenv

{
   putenv_read
   Memcheck:Addr1
   ...
   fun:putenv
}

{
   getenv_read
   Memcheck:Addr2
   ...
   fun:getenv
}

# Leak in u1db_open() if database cannot be opened because of missing read permission
{
   u1db_open_fail
   Memcheck:Leak
   match-leak-kinds: definite
   fun:malloc
   obj:/usr/lib/x86_64-linux-gnu/libsqlite3.so.0.8.6
   ...
   fun:u1db_open
   fun:_ZN5unity6scopes8internal10SettingsDB16process_all_docsEv
   fun:_ZN5unity6scopes8internal10SettingsDB8settingsEv
}

# False positives for memory leaks in glib

{
   calloc[Memcheck:Leak]
   Memcheck:Leak
   fun:calloc
   fun:g_malloc0
   ...
   fun:call_init.part.0
   fun:call_init
   fun:_dl_init
}

{
   realloc[Memcheck:Leak]
   Memcheck:Leak
   fun:realloc
   fun:g_realloc
   fun:g_datalist_id_set_data_full
}

{
   calloc[Memcheck:Leak]
   Memcheck:Leak
   ...
   fun:g_socket_create_source
}

{
   calloc[Memcheck:Leak]
   Memcheck:Leak
   ...
   fun:g_signal_connect_data
}

{
   g_type_class_ref[Memcheck:Leak]
   Memcheck:Leak
   ...
   fun:g_type_class_ref
}

{
   g_type_register_static[Memcheck:Leak]
   Memcheck:Leak
   ...
   fun:g_type_register_static
}

{
   g_type_register_fundamental[Memcheck:Leak]
   Memcheck:Leak
   ...
   fun:g_type_register_fundamental
}

{
   g_type_add_interface_static[Memcheck:Leak]
   Memcheck:Leak
   ...
   fun:g_type_add_interface_static
}

{
   malloc[Memcheck:Leak]
   Memcheck:Leak
   ...
   fun:signon_auth_session_new
}

{
   malloc[Memcheck:Leak]
   Memcheck:Leak
   ...
   fun:signon_auth_session_process_async
}

{
   ag_auth_data_unref[Memcheck:Cond]
   Memcheck:Cond
   fun:ag_auth_data_unref
}

{
   malloc[Memcheck:Leak]
   Memcheck:Leak
   fun:malloc
   fun:g_malloc
   fun:g_slice_alloc
   fun:g_slice_alloc0
   ...
   fun:ag_manager_get_service
   ...
   fun:ag_manager_list_services_by_type
   fun:ag_account_list_services
}

{
   operator new(unsigned long)[Memcheck:Leak]
   Memcheck:Leak
   fun:_Znwm
   fun:_ZNSs4_Rep9_S_createEmmRKSaIcE
}

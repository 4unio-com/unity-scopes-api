#
# Copyright (C) 2013 Canonical Ltd
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authored by: Michi Henning <michi.henning@canonical.com>
#

-------------------------------------------------------------------------------------
NOTE: Before making changes to the code, please read the README file in its entirety!
-------------------------------------------------------------------------------------


Building the code
-----------------

By default, the code is built in release mode. To build a debug version, use

    $ mkdir builddebug
    $ cd builddebug
    $ cmake -DCMAKE_BUILD_TYPE=debug ..
    $ make

For a release version, use -DCMAKE_BUILD_TYPE=release

Running the tests
-----------------

    $ make
    $ make test

Note that "make test" alone is dangerous because it does not rebuild
any tests if either the library or the test files themselves need
rebuilding. It's not possible to fix this with cmake because cmake cannot
add build dependencies to built-in targets. To make sure that everything
is up-to-date, run "make" before running "make test"!

To run the tests with valgrind:

    $ make valgrind

Coverage
--------

To build with the flags for coverage testing enabled and get coverage:

    $ mkdir buildcoverage
    $ cd buildcoverage
    $ cmake -DCMAKE_BUILD_TYPE=coverage
    $ make
    $ make test
    $ make coverage

Note that, with gcc 4.7.2 and cmake 2.8.10, you may get a bunch of
warnings. To fix this, you can build cmake 2.8.10 with the following patch:

http://cmake.org/gitweb?p=cmake.git;a=commitdiff;h=61ace1df2616e472d056b302e4269cbf112fb020#patch1

Unfortunately, it is not possibly to get 100% coverage for some files,
mainly due to gcc's generation of two destructors for dynamic and non-
dynamic instances. For abstract base classes and for classes that
prevent stack and static allocation, this causes one of the destructors
to be reported as uncovered.

There are also issues with some functions in header files that are
incorrectly reported as uncovered due to inlining, as well as
the impossibility of covering defensive assert(false) statements,
such as an assert in the default branch of a switch, where the
switch is meant to handle all possible cases explicitly.

If you run a binary and get lots of warnings about a "merge mismatch for summaries",
this is caused by having made changes to the source that add or remove code
that was previously run, so the new coverage output cannot sensibly be merged
into the old coverage output. You can get rid of this problem by running

    $ make clean-coverage

This deletes all the .gcda files, allowing the merge to succeed again.

If lcov complains about unrecognized lines involving '=====',
you can patch geninfo and gcovr as explained here:

https://bugs.launchpad.net/gcovr/+bug/1086695/comments/2

To run the static C++ checks:

    $ make cppcheck

Code style
----------

We use a format tool that fixes a whole lot of issues
regarding code style. The formatting changes made by
the tool are generally sensible (even though they may not be your
personal preference in all case). If there is a case where the formatting
really messes things up, consider re-arranging the code to avoid the problem.
The convenience of running the entire code base through the pretty-printer
far outweighs any minor glitches with pretty printing, and it means that
we get consistent code style for free, rather than endlessly having to
watch out for formatting issues during code reviews.

To format specific files:

    ${CMAKE_BINARY_DIR}/tools/formatcode x.cpp x.h

If no arguments are provided, formatcode reads stdin and writes
stdout, so you can easily pipe code into the tool from within an
editor. For example, to reformat the entire file in vi (assuming
${CMAKE_BINARY_DIR}/tools is in your PATH):

    1G!Gformatcode

To re-format all source and header files in the tree:

    $ make formatcode

Thread and address sanitizer
----------------

Set SANITIZER to "thread" or "address" to build with the
corresponding sanitizer enabled.

zmq (as 3.2.3 and 4.0.3) causes a large number of warnings from
thread sanitizer. It appears impossible to avoid these; they
are caused by issues in the zmq library. The tsan-suppress file
supresses the benign race conditions we currently know about. To
run the tests (from the build directory) with these suppressions
enabled, use:

    $ TSAN_OPTIONS="suppressions=../tsan-suppress" make test

Updating symbols file
---------------------

To easily spot new/removed/changed symbols in the library, the debian
package is maintaining a .symbols file which lists all exported symbols
present in the library .so. If you add new public symbols to the library,
it's necessary to refresh the symbols file, otherwise the package will
fail to build. The easiest way to do that is using bzr-builddeb:

    $ bzr bd
    $ # this will exit with an error if symbols file isn't up-to-date
    $ cd ../build-area/unity-scopes-api-[version]
    $ cat ./debian/libunity-scopes2/DEBIAN/symbols | c++filt | sed 's/^ \(.*@Base\)/ (c++)"\1"/' | uniq | diff -u debian/libunity-scopes2.symbols - | sed 's/^+ \(.*@Base"\)\( .*\)/+ \1 0replaceme/' > /tmp/symbols.diff
    $ cd -
    $ # review the symbol differences and if everything is ok, apply the diff
    $ patch -p0 < /tmp/symbols.diff

Debugging IPC
-------------

There are lots of messages being passed between the various scope processes,
and therefore it might be sometimes useful to see those to help with debugging.
There is a special monitoring code that is enabled if you pass
-DIPC_MONITORING=ON to cmake. When you build the library with this code,
the messages can be introspected using the python scripts in the tools directory.

Note that the tools require python dependencies that are otherwise not required
for regular builds, to get those, grab python-zmq and python-capnproto.

As of time of writing this, python-capnproto is not present in the distro,
so get it from https://github.com/jparyani/pycapnp.git, also note that the master
branch is compatible with capnproto 0.3, not 0.4 which we're using, so you need
to switch to the "feature/v0.4" branch.

Once you have the extra python dependencies you need to run:

    $ ./zmq-monitor-host.py &

This runs a monitor proxy that forwards the monitored messages from all publishers
to all subscribers.
Then you can run a subscriber that will display content of the messages:

    $ ./zmq-parser.py

Autopkg test suite
------------------

Scopes comes with an autopkg smoke test.

http://packaging.ubuntu.com/html/auto-pkg-test.html

Running the test manually is simple. After building and installing the
new packages, just run 'sh debian/tests/scopebuild'.

When making API breaks, make sure to check if autopkg test scripts
need changing. The point of autopkg is not to exercise the API
thoroughly, so it should not need changing all that often.

At the moment it is unclear if these tests are executed during Jenkins
builds.  This will lead to autopkgtest failing later if scopes' API is
changed in a backwards incompatible way. If this happens the test
needs to be fixed either by updating the test or backing out the API
breaking change.

ABI compatibility
-----------------

By definition, if a change is ABI compatible, you must increment
UNITY_SCOPES_MICRO in CMakeLists.txt.

For ABI incompatible changes, either UNITY_SCOPES_MINOR or
UNITY_SCOPES_MAJOR must be incremented, and the lower-order
version numbers should be reset to zero.

UNITY_SCOPES_MAJOR is meant to indicate major official releases.
What is "major" or "official" is somewhat arbitrary; unless we
are about to release a new Ubuntu version or there are major
feature changes in the scopes run time or API, incrementing
UNITY_SCOPES_MINOR is sufficient.

The .so version for the library is <major><minor>. For example,
version 0.6.3 has the name libunity-scopes.so.06.
This is defined in CMakeLists.txt as UNITY_SCOPES_SOVERSION.

When incrementing the minor or major version number, follow these steps:

1) Set UNITY_SCOPES_MAJOR, UNITY_SCOPES_MINOR, and UNITY_SCOPES_MICRO
   in CMakeLists.txt as appropriate. This automatically sets
   UNITY_SCOPES_SOVERSION.

2) Add an entry to debian/changelog with the new version number.

3) Modify debian/control/unity-scopes-api and modify the
   Package name for the new version. For example, when
   changing from version 0.6.3 to 1.0.0, set the Package
   to "libunity-scopes10".

   Add the previous version (such as libunity-scopes06) to
   the "Replaces" and "Conflicts" sections.

   Update the "Depends" section with the new soversion.

4) Rename the following files to reflect the new soversion.

   libunity-scopes<soversion>.install
   libunity-scopes<soversion>.scope.click-hook
   libunity-scopes<soversion>.symbols

5) Edit the first line of libunity-scopes<soversion>.symbols
   to reflect the new soversion (two occurences on that line).
